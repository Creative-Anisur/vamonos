<html><head>
    <title>Dynamic Programming</title>

    <meta id="meta" name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="../lib/vamonos.css">

    <script type="text/javascript" src="../lib/vamonos-all.js"></script>

    <link rel="stylesheet" href="../deps/bootstrap.min.css">
    <link rel="stylesheet" href="../deps/bootstrap-theme.min.css">
    <script type="text/javascript" src="../deps/bootstrap.min.js"></script>

    <style type="text/css">

    p.caption {
        font-size: 20px;
        font-family: monospace;
    }

    div.center {
        text-align: center;
    }

    h1, h2, h3, h4, h5, h6 {
        text-align: center;
    }

    .math {
        font-family: serif;
    }

    </style>

    <script>


    $( function(){
        $("div#tab2").hide();
        $("div#tab3").hide();
    });

    function tab(n) {
        var active = [1,2,3].filter(function(x){ return x !== n })
        active.forEach(function(x){
            $("li#tabbutt" + x).removeClass("active");
            $("div#tab" + x).hide();
        });
        $("li#tabbutt" + n).addClass("active");
        $("div#tab" + n).show();

        $("html, body").animate({ scrollTop: 0 }, "slow");
    }


    </script>

</head><body>
    <!-- Static navbar -->
    <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#">Dynamic Programming</a>
            </div>
            <div class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li id="tabbutt1" class="active"><a onclick="tab(1);">Introduction</a></li>
                    <li id="tabbutt2"><a onclick="tab(2);">Recursive Solution</a></li>
                    <li id="tabbutt3"><a onclick="tab(3);">DP Solution</a></li>
                </ul>
            </div><!--/.nav-collapse -->
        </div><!--/.container-fluid -->
    </div>

    <div id="tab1" class="container-fluid">

        <div class="row">
            <div class="col-sm-6 col-sm-offset-3">
                <h3>Fibonacci's overlapping subproblems</h3>

                <p>
                    We all know and love the Fibonacci sequence, which is defined as:
                </p>

                <div class="panel panel-default">
                    <div class="panel-heading">
                        Fibonacci Formula
                    </div>
                    <div class="panel-body math">
                        F<sub>0</sub> = F<sub>1</sub> = 1<br>
                        F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub> for <i>n</i> &geq; 2
                    </div>
                </div>

                <p>
                    We can transform this definition into a recursive algorithm quite easily:
                </p>
                <div class="panel vamonos panel-default">
                    <div class="panel-heading">
                        Fibonacci Implementation
                    </div>
                    <div class="pseudocode-procedures">
                        <div id="fib" title="Fib(n):">
                            if n >= 1 then
                                return 1
                            else
                                return fib(n-1) + fib(n-2)
                        </div>
                    </div>
                    <div id="fib-controls"></div>
                    <table class="variable-widgets">
                        <tr><td><div id="fib-stack-var"></div></td>
                            <td><div id="fib-stack"></div></td>
                        </tr>
                    </table>
                </div>

                <p>
                    What could be wrong with that? For one thing, most calls to fib() are needlessly
                    re-computed many times with the same argument!
                </p>

                <p>
                    We say that this algorithm suffers from **overlapping subproblems**. As an
                    example, the value of fib(3) is requested -- directly or indirectly -- by many
                    other calls to fib().
                </p>
            </div>
        </div>

        <ul class="pager">
            <li><a onclick="tab(2)">Next</a></li>
        </ul>

    </div>

    <div id="tab2" class="container-fluid">
        <div class="row">
            <div class="col-sm-7 col-sm-offset-3">
                <h3 id="recursive_solution">To Formalize This</h3>

                <p>
                    We can definitely break this up into smaller problems. That's what we call <a
                    href="https://en.wikipedia.org/wiki/Optimal_substructure">optimal substructure</a>.  If
                    we know the longest increasing subsequence of the list ending with A[i-1], we can easily
                    compute the longest increasing subsequence of A[i]. We can create a recursive function L
                    to calculate this recursively.
                </p>

                <p class='caption' align='center'>
                    <table>
                        <tr><td>
                            L[0] =
                        </td><td>
                            0
                        </td></tr>
                        <tr><td>
                            L[n] =
                        </td><td>
                            1 + max{ L[j]: for all j < n such that A[j] < A[n] }<br>
                        </td></tr>
                    </table>
                </p>

                <p>
                    We could implement this. By the way, we use 1-indexed arrays, so we can have a neat base
                    case of 0. We also do this to complicate programming!
                </p>
            </div>
        </div>

        <br>

        <div class="jumbotron row">
            <div class="panel row panel-default">
                <div class="panel-heading">
                    Recursive LIS Implementation
                </div>
                <div class="col-sm-5 vamonos">
                    <div id="controls-l"></div>
                    <div class="pseudocode-procedures">
                        <div id="pseudocode-l-caller" title="LIS(A):">
                            R = []
                            for i = 0 upto A.length
                                v = L(A,i)
                                R.push(v)
                            return max(R)
                        </div>
                        <div id="pseudocode-l" title="L(n):">
                            if n = 0
                                return 0
                            M = []
                            for all j such that A[j] < A[n]
                                v = L(j)
                                M.push(v)
                            return 1 + max(M)
                        </div>
                    </div>
                </div>
                <div class="col-sm-7 vamonos">
                    <table class="variable-widgets">
                        <tr><td><div id="A-var-l"></div></td>
                            <td><div id="A-l"></div></td>
                        </tr>
                        <tr><td><div id="R-var-l"></div></td>
                            <td><div id="R-l"></div></td>
                        </tr>
                        <tr><td><div id="stack-var-l"></div></td>
                            <td><div id="stack-l"></div></td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-xs-3 col-xs-offset-2">
                <div class="panel panel-default">
                    <div class="panel-heading">Calls to L(n)</div>
                    <table id="l-results" class="table table-bordered table-striped table-condensed"> </table>
                </div>
            </div>

            <div class="col-xs-5">
                <h3>Overlapping Subproblems</h3>
                <p>
                    The problem with this implementation is that it calls L many times with the same n.
                    That's the other incredient of a problem we can attack using dynamic programming: <a
                    href="https://en.wikipedia.org/wiki/Overlapping_subproblems">overlapping
                    subproblems</a>. In fact, in the worst case, there will be O(2<sup>n</sup>) of
                    them. What is the worst case input? <span id="quiz" class="text-warning">The current input is
                    not the worst-case input. Try changing it!</span>
                </p>
            </div>
        </div>

        <ul class="pager">
            <li><a onclick="tab(1)">Previous</a></li>
            <li><a onclick="tab(3)">Next</a></li>
        </ul>
    </div>


    <div id="tab3" class="container-fluid">

        <div class="row">
            <div class="col-sm-6 col-sm-offset-3">
                <h3 id="dp_solution">Dynamic Programming</h3>
                <p>
                    Dynamic programming is easy! All we do is start from the bottom of the problem instead
                    of the top. We just use an array to keep track of the answers we've gotten already, and
                    refer to that instead of recursing. It certianly helps if you know the formal equation
                    of the problem (our L above), so I would recommend starting with that when you try
                    solving your own dynamic programming problems.
                </p>
            </div>
        </div>

        <br>

        <div class="jumbotron row">
            <div class="panel row panel-default">
                <div class="panel-heading">
                    Dynamic Programming LIS Implementation
                </div>
                <div class="col-sm-5 vamonos">
                    <div id="controls"></div>
                    <div class="pseudocode-procedures">
                        <div id="pseudocode" title="LIS(A):">
                            L[0] = 0
                            for n = 1 to A.length
                                L[n] = 1
                                for j = 1 to n-1
                                    if A[j] &lt; A[n] and L[n] &lt; L[j] + 1
                                    L[n] = L[j] + 1
                        </div>
                    </div>
                </div>
                <div class="col-sm-7 vamonos">
                    <table class="variable-widgets">
                        <tr><td><div id="A-var"></div></td>
                            <td><div id="A"></div></td>
                        </tr>
                        <tr><td><div id="L-var"></div></td>
                            <td><div id="L"></div></td></tr>
                    </table>
                </div>
            </div>
        </div>


        <div class="row">
            <div class="col-sm-6 col-sm-offset-3">
                <h3>Runtime Analysis</h3>
                <p>
                    Since we keep eliminate the subproblems, we end up with a linear runtime. Which is
                    awesome compared to the exponential one above. Maybe Mike can think of some more stuff
                    to say here.
                </p>
            </div>
        </div>

        <ul class="pager">
            <li><a onclick="tab(2)">Previous</a></li>
        </ul>
    </div>
------------

## Caching

One way to avoid computing the same value twice is to bolt on a *cache* to the algorithm. At the beginning of every call to fib(n), we check whether the answer is already in the cache. Otherwise, we compute the answer just as before, and store the answer in the cache just before returning. We call this **recursion with shortcuts**.

   static cache[] // syntax??
   // cache[n] will store the already-computed result of fib(n)
   fib(n):
       if cache[n] exists then
           return cache[n]
       if n <= 1 then
           cache[n] = 1
       else
           cache[n] = fib(n-1) + fib(n-2)
       return cache[n]

This algorithm won't needlessly recompute a value fib(n) after computing it once. But this style of coding is slightly cumbersome since:

* It is hard to analyze/understand, because it relies heavily on side-effects. The same call to fib() could result in different behavior based on the contents of the cache.

* Correctly maintaining the cache is awkward when using a static/global cache variable like this. For future problems we will discuss, a cache can be made to work but only if it is cleared for some calls but not others.

Q: when calling fib(5) with an initially empty cache, what will be the first entry in the cache to be added?

TRY IT

----------

## Top-down vs Bottom-up

In the previous example, the cache gets filled starting at the base cases 0 & 1 and then gets filled up in increasing order. It makes sense that you can't compute fib(n) until fib(n-1) returns, filling cache[n-1] in the process.

Let's execute the recursion-with-shortcuts algorithm, and imagine that all we can see is how the cache array is filled:

TRY IT

So the recursion-with-shortcuts approach fills the cache in a certain way, and eventually returns the last item added to the cache.

If you were asked to write an algorithm that fills an array in this way, you certainly wouldn't have written the recursion-with-shortcuts approach. You would have written something much more direct:

   fib(n):
       cache[0] = cache[1] = 1
       for i = 2 to n:
           cache[k] = cache[k-1] + cache[k-2]
       return cache[n]

Isn't that nicer?

The two recursion-based approaches work **top-down**, considering larger problems in terms of smaller subproblems. This last, direct approch is **bottom-up**, solving larger and larger subproblems until the desired subproblem has been solved.

----------------

## The Basic Idea

We've seen 3 ways of doing the same simple thing: simple recursion, recursion with shortcuts, and bottom-up.

The bottom-up approach is all there is to dynamic programming! Solve the base cases, then solve the next-smallest subproblems, and so on until you have solved the desired problem.

Many/most students do indeed start out by thinking about the Fibonacci sequence in terms of the bottom-up approach (computing the nth Fibonacci number by enumerating 0,1,2,3,5,8,...). Then a CS education takes great pains to force students to think about things in a recursive way (F(n) = F(n-1) + F(n-2)).

Now we are asking you to go back to the bottom-up approach? Don't worry, the Fibonacci example is misleadingly simple. To use dynamic programming to its greatest benefit, you **must** understand the recursive top-down approach first, only then can you convert to a bottom-up algorithm.

----------------

## First example: Work Bonus Scheduling

You work in outdoor construction in a hot climate, and get paid a daily bonus based on the high temperature that day. If the high temperature is T degrees, then you get a $T bonus (temperatures in this region are always positive). Local safety regulations also say that no one can work on consecutive days.

Suppose you know the forecast for the next n days, represented as an array T[1..n]. T[i] is the high temperature, i days from now. What is the maximum bonus you can receive over the next n days, assuming the forecast is correct and assuming you are in it just for the money (and are willing to work in any weather)?

Example: Suppose the forecast is [93,91,87,72,85,88]. You can work on odd days to get a bonus of 93+87+85=265, or even days to get a bonus of 91+72+88=251. But even better would be to work on days 1, 3, and 6 to get a bonus of 93+87+88=268.

To get started solving this problem, let's first just worry about computing *the maximum bonus*, and not worry about *which schedule achieves* the maximum bonus. So, given the above example forecast, we would like to compute the number 268.

Now suppose you are given a forecast T[1..n]. What do you do? To master the dynamic programming technique, you'll have to get used to the following kind of logic:

1. If you decide to work on the nth day, you will get a bonus of T[n]. But then you can't work on the (n-1)th day, so the remainder of your schedule will be some subset of days 1 through n-2.

2. If you decide *not* to work on the nth day, then you'll be working in some subset of days 1 through n-1.

Those are the only two choices, right? Either work on the nth day, or don't work on the nth day.

Define best[k] to be the maximum possible bonus you can get by working during days 1 through k. Then let's revisit those two cases:

1. You work on the nth day, earning T[n]. You also work some time during days 1 through n-2. The most that can give you is best[n-2]. Hence the most you can get from this case is best[n-2] + T[n].

2. You don't work on the nth day, you only work during days 1 through n-1. The most you that can give you is best[n-1].

So when thinking about what to do on the nth day, there are only two choices: choose to earn T[n] + best[n-2], or choose to earn best[n-1]. Of course you would choose whichever of these is highest, right? So we get:

   best[n] = max{ T[n] + best[n-2], best[n-1] }

Of course, this formula only makes sense when n > 1. The base cases have to be best[1] = T[1] (it's always better to work than not to work, when considering only one day) and best[0] = 0 (working on zero days gives you zero bonus).

Hey, this is a recursive formula, which we could translate directly to a recursive algorithm. But it would suffer from overlapping subproblems! Calling it with input n would result in recursive calls on n-1 and n-2, just like the recursive algorithm for the Fibonacci numbers!

So instead, we will use dynamic programming, computing best[k] values **bottom-up**. Remember the basic approach? We are just filling in a table. The first entries we fill in are the base cases. Then we fill entries in a legal order, using the recurrence formula.

   schedule(T[1..n]):
       best[0] = 0
       best[1] = T[1]
       for k = 2 to n:
           best[k] = max{ best[k-2] + T[k], best[k-1] }
       return best[n]

Q: predict values that will be filled in!

------------

## Getting the answer, not just the number

For our previous problem, we can now find the best bonus amount for a given forecast. But we probably also care about what schedule actually achieves that bonus amount. Let's discuss how to do that.

The idea is that each time we compute best[k] (a number), we should also write down and remember *how* to achieve best[k]. In this case, we need to write down the schedule that achieves best[k]. There are several ways to do this, but perhaps the simplest is as a string of "Y" and "N" characters. So the string "YNNYN" represents the schedule of working on days 1 & 4, and resting on days 2, 3 & 5.

Let's store the schedules in an array soln[1..n]. Again, the rule is: every time you save a number to best[k], you must also save the corresponding schedule to soln[k]. Note that soln[k] must be a string of length k.

The base cases are: best[1] = T[1], and best[0] = 0. What are the corresponding values to put in soln[]? The schedule that achieves 0 is the empty string, and the schedule that achieves T[1] is "Y". Note that the lengths of strings soln[0] and soln[1] match what we expect.

Now, for best[k] there are two possibilities:

1. best[k] = best[k-2] + T[k]. This happens when we work on the kth day and rest on the (k-1)th day. So the last 2 characters of soln[k] should be "NY". But what should soln[k] say for the other days? We know that the other days contribute best[k-2] amount to the total. Conveniently, soln[k-2] is a schedule for those days that achieves it. Hence, we have soln[k] = soln[k-2] + "NY", where the + here means concatenation.

2. best[k] = best[k-1]. This happens when we rest on the kth day. So the last character of soln[k] must be "N". What is the rest of the schedule? Well, it's a schedule for days 1 through k-1 that achieves bonus best[k-1]. We have already written down such a schedule, it's simply soln[k-1]. So we have soln[k] = soln[k-1] + "N" in this case.

Putting it all together, we have to break up the "max" expression into an if-statement:

   schedule(T[1..n]):
       best[0] = 0
       soln[0] = ""
       best[1] = T[1]
       soln[1] = "Y"
       for k = 2 to n:
           if best[k-2] + T[k] > best[k-1]
               best[k] = best[k-2] + T[k]
               soln[k] = soln[k-2] + "NY"
           else
               best[k] = best[k-1]
               soln[k] = soln[k-1] + "N"
       return soln[n] + " achieves bonus " + best[n]

I happen to think that there is some elegance in how the two arrays, "best" and "soln", are always accessed in a similar manner.

Q: can you come up with an input whose optimal solution involves *not* working on the day with the highest temperature?

------------scratch space below here -------------------

## Another example: Binomial coefficients

You may have seen the formula for binomial coefficients {n \choose k} = \frac{n!}{k!(n-k)!}, but this is a bad way to actually *compute* these numbers. For instance, even if the final result is small (ex: (1000 \choose 1) = 1000) the intermediate values of this computation may be huge (ex: factorial(1000)).

Another way to compute binomial coefficients is to use Pascal's identity, which is recursive:

   (n \choose 0) = (n \choose n) = 1
   (n \choose k) = (n-1 \choose k-1) + (n-1 \choose k)

We could blindly convert this recursive formula into a recursive algorithm:

   choose(n,k):
       if k == 0 or k == n:
           return 1
       else
           return choose(n-1,k-1) + choose(n-1,k)

But again this algorithm suffers from serious overlapping subproblems!

SEE RECURSION TREE

The dynamic programming approach would be to fill up a table/cache with all of the desired values. In this case, the table will be two-dimensional, so cache[n][k] will remember the output of choose(n,k).

First, we fill in the base cases: in this case, there are many. Then we have to fill in everything else. We know we will have to fill entry (i,j) of the table using the expression:

   cache[i,j] = cache[i-1,j-1] + cache[i-1,j]

We just have to loop over value of (i,j) in a way that makes this legal. That is, we want cache[i-1,j-1] and cache[i-1,j] to already exist when it comes time to fill in cache[i,j].

There are several legal ways to fill up the cache, and here's one:

   choose(n,k):
       for i = 0 to n:
           cache[i,0] = 1
           cache[i,i] = 1
       for i = 1 to n:
           for j = 1 to k:
               cache[i,j] = cache[i-1,j-1] + cache[i-1,j]
       return cache[n,k]

Do you see the resemblance to Pascal's triangle?

Q: can you think of different legal ways to fill up the cache? How would it change the code?

------------

</body>
<script type="text/javascript">

Array.prototype.compare = function(testArr) {
    if (this.length != testArr.length) return false;
    for (var i = 0; i < testArr.length; i++) {
        if (this[i].compare) {
            if (!this[i].compare(testArr[i])) return false;
        }
        if (this[i] !== testArr[i]) return false;
    }
    return true;
}

function pushResults(){
    var $table = $("table#l-results")
    var $thead = $("<thead>");
    $thead.append($("<th>", { text: "n"}));
    $thead.append($("<th>", { text: "times called"}));
    $table.append($thead);
    for (var n in l_called_on.results) {
        if (l_called_on.results.hasOwnProperty(n)) {
            var val = l_called_on.results[n];
            var $row = $("<tr>");
            $row.append($("<td>", { text: n}));
            $row.append($("<td>", { text: val}));
            $table.append($row);
        }
    }
}

function l_called_on(n){
    var elem = l_called_on.results[n];
    if (elem === undefined) l_called_on.results[n] = 0;
    l_called_on.results[n] += 1;
}

function l_called_on_init() {
    l_called_on.results = {};
}

function quiz_check_input(A) {
    var $elem = $("span#quiz")
    var A = A.slice(1);
    var B = A.slice(0).sort();
    if (A.compare(B)) {
        quiz_check_input.backup = $elem.text()
        $elem.text("Yep. The worst-case is when A is sorted.")
        $elem.removeClass("text-warning");
        $elem.addClass("text-success");
    } else if (quiz_check_input.backup) {
        $elem.removeClass("text-success");
        $elem.addClass("text-warning");
        $elem.text(quiz_check_input.backup);
    }
}

var myviz1 = new Vamonos.Visualizer({
    widgets: [
        new Vamonos.Widget.Array({
            container: "A-l",
            varName: "A",
            defaultInput: [0, 3,1,4,1,5,9,2,6,5],
            ignoreIndexZero: true,
            cssRules: [[">", "j", "shaded"]],
            showIndices: ["n", "j"],
        }),

        new Vamonos.Widget.Pseudocode({
            container: "pseudocode-l-caller",
        }),

        new Vamonos.Widget.Pseudocode({
            container: "pseudocode-l",
            procedureName: "l_rec",
        }),

        new Vamonos.Widget.Controls({ container: "controls-l" }),

        new Vamonos.Widget.VarName({
            container: "A-var-l",
            varName: "A",
        }),

        new Vamonos.Widget.VarName({
            container: "R-var-l",
            varName: "global::R",
            displayName: "R",
            watching: true,
        }),

        new Vamonos.Widget.Array({
            container: "R-l",
            varName: "global::R",
            ignoreIndexZero: true,
            displayOnly: true,
            showIndices: ["i"],
        }),

        new Vamonos.Widget.VarName({
            container: "stack-var-l",
            varName: "_callstack",
            displayName: "Call Stack",
            watching: true,
        }),

        new Vamonos.Widget.CallStack({
            container: "stack-l",
            procedureNames: {
                main: "LIS",
                l_rec: "L",
            },
        }),

    ],

    algorithm: {
        main: function(_){
            with (this) {
                l_called_on_init();
                quiz_check_input(A);
                _(1);
                global.R = [0];
                global.A = A;
                for (i = 1; _(2), i < A.length; i++) {
                    _(3);
                    var v = l_rec({ n:i });
                    _(4);
                    global.R.push(v);
                }
                _(5);
                pushResults();
                return Math.max.apply(this, global.R);
            }
        },

        l_rec: function(_){
            with (this) {
                l_called_on(n);
                if (_(1), n === 0) {
                    _(2);
                    return 0
                }
                _(3);
                _(4);
                var M = [];
                for (var i = n - 1; i >= 0; i--) {
                    if (global.A[i] >= global.A[n]) continue;
                    _(5);
                    j = i;
                    _(6);
                    var v = l_rec({ n: j });
                    _(7);
                    M.push(v);
                }
                _(8);
                if (global.A[n] === undefined) {
                    return Math.max.apply(this, M);
                } else if (M.length) {
                    return 1 + Math.max.apply(this, M);
                } else {
                    return 1;
                }
            }
        },
    },

    maxFrames: 100000,
    unbounded: true,
});

myviz1.runAlgorithm();
myviz1.trigger('editMode');


var myviz2 = new Vamonos.Visualizer({
    widgets: [

        new Vamonos.Widget.VarName({
            container: "A-var",
            varName: "A",
        }),

        new Vamonos.Widget.Array({
            container: "A",
            varName: "A",
            defaultInput: [0, 3,1,4,1,5,9,2,6,5],
            ignoreIndexZero: true,
            cssRules: [[">", "j", "shaded"]],
            showIndices: ["n", "j"],
            firstCellBlank: true,
        }),

        new Vamonos.Widget.VarName({
            container: "L-var",
            varName: "global::L",
            displayName: "L",
            watching: true,
        }),

        new Vamonos.Widget.Array({
            container: "L",
            varName: "global::L",
            displayOnly: true,
            showIndices: ["n", "j"],
        }),

        new Vamonos.Widget.Pseudocode("pseudocode"),

        new Vamonos.Widget.Controls({
            container: "controls",
        }),
    ],

    algorithm: function (_) {
        with (this) {
_(1);       global.L = [0]
_(2);       for (n = 1; n < A.length; _(2), n++) {
_(3);           global.L[n] = 1;
_(4);           for (j=1; j<n; _(4), j++) {
_(5);               if (A[j] < A[n] && global.L[n] < global.L[j] + 1) {
_(6);                   global.L[n] = global.L[j] + 1;
                     }
                }
                j = undefined;
            }
            n = undefined;
        }
    }
});


var fib = new Vamonos.Visualizer({
    widgets: [
        new Vamonos.Widget.Hardcoded({
            n: 10,
        }),

        new Vamonos.Widget.Pseudocode("fib"),
        new Vamonos.Widget.Controls("fib-controls"),

        new Vamonos.Widget.CallStack({
            container: "fib-stack",
            procedureNames: {
                main: "Fib",
            },
        }),

        new Vamonos.Widget.VarName({
            container: "fib-stack-var",
            varName: "_callstack",
            displayName: "Call Stack",
            watching: true
        })
    ],

    algorithm: function(_) {
        with (this) {
            _(1);
            if (n <= 1) {
                _(2);
                return 1;
            }
            _(3);
            _(4);
            var a = main({n:n-1});
            var b = main({n:n-2});
            return a + b;
        }
    },
    maxFrames: 500,
});


</script>
</html>
